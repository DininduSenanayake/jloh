#!/usr/bin/env python3

# version and info
script_info = """
###
Author: Matteo Schiavinato
Based on the work of: Leszek Pryszcz (2014) and Veronica Mixao (2018)
Last change: 03/12/2021
###
"""

# import modules
import argparse as ap
import os
import sys
import pysam
import subprocess

# help section
if len(sys.argv) == 1:
	sys.argv.append("--help")

if (sys.argv[1] in ["--help", "-h", "-help", "help", "getopt", "usage"]):
	sys.stderr.write("""

J LOH
Still the one from the block
-
Extact LOH blocks from SNPs and a reference genome
-
v 0.1.0
--------------------------------------------------------------------------------
by Matteo Schiavinato
based on the work of Leszek Pryszcz and Veronica Mixao
DOIs:
Pryszcz et al., 2014	https://doi.org/10.1093/gbe/evu082
Mixao et al., 2019		https://doi.org/10.3389/fgene.2019.00383
--------------------------------------------------------------------------------

Usage:
./jloh --vcf <VCF> --genome-file <GENOME_FILE> --bam <BAM> [options]

[mandatory]
--vcf               Input VCF file containing all types of variants             [!]
--genome-file       File with chromosome lengths (chromosome <TAB> size)        [!]
--bam               BAM file used to call the --vcf variants                    [!]

[optional]
--sample            Sample name / Strain name for output files                  [loh_blocks]
--output-dir        Output directory                                            [loh_blocks_out]
--t0-vcf            VCF with variants to ignore from --vcf                      [off]
--min-het-snps      Min. num. of heterozygous SNPs in heterozygous region       [2]
--snp-distance      Min. distance (bp between SNPs for blocks definition        [100]
--min-size          Min. LOH block size                                         [100]
--block-lengths     Comma-sep. list of desired distances between LOH blocks     [100,1000,5000]
--min-af            Min. allele frequency to consider a variant heterozygous    [0.3]
--max-af            Max. allele frequency to consider a variant heterozygous    [0.7]
--min-frac-cov      Min. mean coverage fraction for LOH blocks                  [0.75]
                    (used only if --bam specified)
--max-frac-cov      Max. mean coverage fraction for LOH blocks                  [1.25]
                    (used only if --bam specified)
--bedtools          Path to the bedtools executable                             [bedtools]
--print-info        Show authors and edits with dates                           [off]

""")
	sys.exit(0)

# argument parser
p = ap.ArgumentParser(description="")
p.add_argument("--vcf", type=str)
p.add_argument("--genome-file")
p.add_argument("--sample", default="loh_blocks")
p.add_argument("--output-dir", default="loh_blocks_out")
p.add_argument("--t0-vcf", type=str, default=None)
p.add_argument("--min-het-snps", type=float, default=2)
p.add_argument("--snp-distance", default=100, type=int)
p.add_argument("--min-size", default=100, type=int)
p.add_argument("--block-lengths", default="100,1000,5000", type=str)
p.add_argument("--min-af", default=0.3, type=float)
p.add_argument("--max-af", default=0.7, type=float)
p.add_argument("--bam", type=str)
p.add_argument("--min-frac-cov", type=float, default=0.75)
p.add_argument("--max-frac-cov", type=float, default=1.25)
p.add_argument("--bedtools", default="bedtools")
p.add_argument("--print-info", action="store_true")
args = p.parse_args()

# functions
def organize_workspace(output_dir, min_frac_cov, max_frac_cov, bam):

	"""
	Creation of folders and workspace where the script has to operate
	Verify presence of minimal set of files to work with
	"""

	if os.path.exists(output_dir) == False:
		os.makedirs(output_dir)
		sys.stderr.write(f"Created output directory {output_dir}\n")

	if os.path.exists(f"{output_dir}/process") == False:
		os.mkdir(f"{output_dir}/process")

	# check if bam is used or not
	if bam and not (min_frac_cov or max_frac_cov):
		sys.stderr.write("ERROR: If you specify a --bam file you may want to use --min-frac-cov or --max-frac-cov\n")
		sys.exit(1)

	if (min_frac_cov or max_frac_cov) and not bam:
		sys.stderr.write("ERROR: If you use --min-frac-cov or --max-frac-cov you may want to specify a --bam file\n")
		sys.exit(1)

	return (True, output_dir)


def select_relevant_variants(output_dir, sample, t0_vcf, bedtools, vcf, filt_vcf_out):

	"""
	v1
	Author: Matteo Schiavinato
	Last change: 02/12/2021
	Removing variants annotated in the declared t0_vcf file
	If not declared, all variants are retained
	Which means that the whole input --vcf is assigned as filt_vcf_out
	"""

	if t0_vcf != None:
		sys.stderr.write("Removing T0 variants...\n")
		cmd = f"{bedtools} intersect -header -u -a {vcf} -b {t0_vcf} > {filt_vcf_out}"
		try:
		    subprocess.run([cmd], check=True, shell=True)
		except subprocess.CalledProcessError:
			sys.stderr.write("ERROR: bedtools intersect didn't work\n")
			sys.exit(1)
	else:
		sys.stderr.write("No T0 VCF declared: preserving all variants for analysis...\n")
		cmd = f"cp {vcf} {filt_vcf_out}"
		try:
		    subprocess.run([cmd], check=True, shell=True)
		except subprocess.CalledProcessError:
			sys.stderr.write("ERROR: couldn't copy input VCF file into output directory\n")
			sys.exit(1)

	return (True, filt_vcf_out, sample)


def extract_heterozygous_snps(vcf, min_af, max_af, output_dir, sample, het_snps_vcf):

	"""
	v1
	Author: Matteo Schiavinato
	Last change: 02/12/2021
	Input: the VCF file containing SNPs and indels
	Output: only heterozygous SNPs, including number of kept and removed lines
	"""

	# iterate over variants
	removed, kept, Lines, New_lines = 0, 0, [], []

	INPUT = open(vcf, "r")
	for line in INPUT:
		if line[0] == "#":
			New_lines.append(line)
		else:
			Lines.append(line.rstrip("\n\r\b").split("\t"))

	for lst in Lines:

		# read values
		annotations = lst[8].split(":")
		values = lst[9].split(":")
		dict = { annotations[i]:values[i] for i in range(0, len(annotations)) }

		# if it's a single heterozygous SNP
		if ((len(lst[3]) == len(lst[4]) == 1) and (dict["GT"]=="0/1")):

			# does AF fit the criteria?
			if (min_af <= float(dict["AF"]) <= max_af):

				# 4. write out lines that have fitting values
				New_lines.append("\t".join(lst) + "\n")
				kept += 1

			# remove those without the frequency in range
			else:
				removed += 1

		# consider multiallelic sites
		elif ((len(lst[3]) == 1) and (len(lst[4].split(",")) > 1)):

			# this means that there are two annotations for AF
			# and that both have to be checked
			# so it is a variation on the previous block
			# which could be rendered into a function
			# assuming that there are > 1 AF annotation
			# splitting the field based on the comma
			# and converting to float the content
			AFs = [ float(x) for x in dict["AF"].split(",") ]

			# all it takes is one of the variants to be heterozygous
			# for the locus to be conserved
			# where het = AF comprised between --min-af and --max-af
			Conditions = [ float(args.min_af) <= af <= float(args.max_af) for af in AFs]
			if any(Conditions) == True:

				# 4. write out lines that have fitting values
				New_lines.append("\t".join(lst) + "\n")
				kept += 1

			# remove those without any heterozygous snp
			# among those available
			else:
				removed += 1

		# remove homozygous SNPs
		# and indels
		else:
			removed += 1

	sys.stderr.write(f"Kept {kept} heterozygous SNPs ({round((kept / (kept + removed))*100, 2)} %) out of {kept+removed} VCF records\n")

	# write filtered bed file lines to an actual bed file output
	OUT = open(het_snps_vcf, "w")
	for line in New_lines:
		OUT.write(line)
	OUT.close()

	return (True, het_snps_vcf)


def merge_bed_intervals(sample, output_dir, snp_distance, bedtools, het_snps_vcf, bed_out):

	"""
	Create BED regions based on the input VCF rows after their filtering
	These regions are --snp-distance large and centered on the SNPs
	For each snp_distance, the number of variants contained in it are counted
	The output is: chr | start | end | count
	"""

	cmd = f"{bedtools} merge -d {snp_distance} -c 1 -o count -i {het_snps_vcf} > {bed_out}"
	try:
	    subprocess.run([cmd], check=True, shell=True)
	except subprocess.CalledProcessError:
		sys.stderr.write("ERROR: bedtools merge didn't work\n")
		sys.exit(1)

	return (True, snp_distance)


def add_length(bed, output_bed):

	"""
	Compute length of BED interval and add it as 5th column
	"""

	INPUT = open(bed, "r")
	Lines = [line.rstrip("\b\r\n").split("\t") for line in INPUT]
	INPUT.close()

	OUTPUT = open(output_bed, "w")
	for lst in Lines:
		chrom, start, end, count = lst
		length = int(end)-int(start)
		OUTPUT.write("\t".join([chrom, start, end, count, str(length)]) + "\n")

	OUTPUT.close()

	return True

def filter_by_snp_density(in_bed, out_bed, output_dir, sample, snp_distance, minC, maxC, minL):

	"""
	Filter regions based on the number of variants found in them
	Which were counted in the previous function

	v1
	Author: Leszek Pryszcz
	Notes: Parse BED and print stats
	Last change: 14/02/2014
	###
	v2
	Author: Matteo Schiavinato
	Notes: included a return statement to fit the new code, update to python3
	Last change: 26/11/2021
	"""

	handle = open(in_bed, "r")

	out = []
	i, skipped = 0, 0
	for l in handle:
		i += 1
		c = 0
		ref,start,end,count,length = l.split()
		ref,start,end,count,length = str(ref),int(start),int(end),float(count),int(length)
		if minC <= count <= maxC and length >= minL:
			out.append(l)
		else:
			skipped += 1

	# write filtered bed file lines to an actual bed file output
	OUT = open(out_bed, "w")
	for line in out:
		OUT.write(line)
	OUT.close()

	return (True, minC, maxC, minL)


def get_complementary_regions(complement_bed, bedtools, filt_bed, genome_file):

	"""
	Run bedtools complement to obtain BED intervals
	These intervals represent the complement of the original regions
	Which in turn represented the heterozygous blocks
	Hence, the output of this function are the homozygous blocks
	"""

	cmd_complement = f"{bedtools} complement -i {filt_bed} -g {genome_file} > {complement_bed}"
	try:
	    subprocess.run([cmd_complement], check=True, shell=True)
	except subprocess.CalledProcessError:
		sys.stderr.write("ERROR: bedtools complement didn't work\n")
		sys.exit(1)

	return True


def filter_by_length(in_bed, out_bed, min_size):

	"""
	Keep only candidate LOH regions of a certain minimum size
	"""

	INPUT = open(in_bed, "r")
	OUTPUT = open(out_bed, "w")

	for line in INPUT:
		chr,start,end = line.rstrip("\n\r\b").split("\t")
		length = int(end) - int(start)
		out_lst = [str(i) for i in [chr,start,end,length]]
		OUTPUT.write("\t".join(out_lst) + "\n")

	INPUT.close()
	OUTPUT.close()

	return True


def filter_by_coverage(bam_file, bed_file, covfr, cmax):

	"""
	v1
	Author: Leszek Pryszcz
	Notes: Report only windows with at least mincov of mean
	Last change: 14/02/2014
	###
	v2
	Author: Matteo Schiavinato
	Notes: included a return statement to fit the new code, update to python3
	Last change: 26/11/2021
	"""

	# open bed file
	bedstream = open(bed_file, "r")

	#calculate mean cov
	sam = pysam.Samfile(bam_file)

	#mean covevarage  = aligned reads / genome size
	meancov = 1.0 * sam.mapped / sum(sam.lengths)

	#select windows
	Out = []
	for bed in bedstream:
		#unload bed coordinate
		chrom, start, end, length = bed.rstrip("\n\b\r").split('\t')
		start, end = int(start), int(end)
		#get read count within range of bed file
		c = sam.count(chrom, start, end)
		#check if correct coverage
		cov = c *1.0 / (end-start)
		if cov < float(covfr) * meancov or cov > float(cmax) * meancov:
			cov = round(cov, 2)
			Out.append(f"{chrom}\t{start}\t{end}\t{cov}\t{length}\n")

	return Out


def main():

	"""
	Function carrying on the main operations
	"""

	# --------------------------------------
	# if required print script info and quit
	if args.print_info:
		print(script_info)
		sys.exit(0)

	# ---------------------------------------
	# create output directory if not existing
	sys.stderr.write("Preparing workspace...\n")
	(result, output_dir) = organize_workspace(	args.output_dir,
												args.min_frac_cov,
												args.max_frac_cov,
												args.bam)

	# ---------------------------------------
	# filter out variants from t0 if required
	sys.stderr.write("Selecting relevant variants...\n")
	filt_vcf_out = f"{output_dir}/process/{args.sample}.relevant.vcf"

	(result, filt_vcf_out, sample) = select_relevant_variants(	output_dir,
																args.sample,
																args.t0_vcf,
																args.bedtools,
																args.vcf,
																filt_vcf_out)

	# -------------------------------------------
	# Extract heterozygous snps from raw VCF file
	sys.stderr.write("Extracting heterozygous SNPs from VCF file...\n")
	sys.stderr.write(f"Considering only SNPs with {args.min_af} <= AF <= {args.max_af}\n")
	het_snps_vcf = f"{output_dir}/{sample}.het_snps.vcf"

	(result, het_snps_vcf) = extract_heterozygous_snps(	filt_vcf_out,
														args.min_af,
														args.max_af,
														output_dir,
														sample,
														het_snps_vcf)

	# -------------------------------------------
	# Get heterozygous blocks with bedtools merge
	# merge bed file
	sys.stderr.write(f"Defining heterozygous blocks for {sample}...\n")
	merged_bed_out = f"{output_dir}/process/{sample}.d{args.snp_distance}bp_provisory.bed"

	(result, snp_distance) = merge_bed_intervals(sample,
												output_dir,
												args.snp_distance,
												args.bedtools,
												het_snps_vcf,
												merged_bed_out)

	# add length to BED file
	sys.stderr.write(f"Calculating length of BED intervals...\n")
	bed_with_length = f"{output_dir}/process/{sample}.d{args.snp_distance}bp_provisory_w_len.bed"

	result = add_length(merged_bed_out, bed_with_length)

	# ---------------------------------------------
	# run filtering function on the merged bed file
	sys.stderr.write("Keeping only blocks with > 1 SNP...\n")
	minC, maxC, minL = float(args.min_het_snps), float("inf"), float(0)
	filt_bed = f"{output_dir}/process/{sample}.d{snp_distance}bp.bed"

	(result, minC, maxC, minL) = filter_by_snp_density(bed_with_length,
														filt_bed,
														output_dir,
														sample,
														snp_distance,
														minC,
														maxC,
														minL)

	# ------------------------------------------------------
	# Obtaining complementary regions to heterozygous blocks
	# get complementary bed file
	sys.stderr.write("Getting complementary regions...\n")
	complement_bed = f"{output_dir}/process/{sample}.d{snp_distance}bp.complement.bed"

	result = get_complementary_regions(complement_bed,
										args.bedtools,
										filt_bed,
										args.genome_file)

	# --------------------------------------------------
	# Filter the complement to get the homozygous blocks
	sys.stderr.write("Getting candidate LOH blocks...\n")
	filt_compl_bed = f"{output_dir}/process/{sample}.homo.d{snp_distance}bp.bed"

	result = filter_by_length(complement_bed,
							filt_compl_bed,
							args.min_size)

	# -----------------------------------------
	# filter by real coverage from the BAM file
	# index bam file
	if os.path.exists(f"{args.bam}.bai") == False:
		sys.stderr.write("BAM index not found. Indexing BAM file...\n")
		pysam.index(args.bam)

	# use the filtered bed file as input for next step
	Final_bed_lines = filter_by_coverage(	args.bam,
											filt_compl_bed,
											args.min_frac_cov,
											args.max_frac_cov)

	final_bed_file = f"{output_dir}/{sample}.LOH_blocks.bed"

	# write final bed file lines to an actual bed file output
	OUT = open(final_bed_file, "w")
	OUT.write("Chromosome\tStart\tEnd\tCoverage\tLength\n")
	for line in Final_bed_lines:
		OUT.write(line)
	OUT.close()

	sys.stderr.write("Done!\n")

# run the script
if __name__=='__main__':
  main()
