#!/usr/bin/env python3

import argparse as ap
import sys
from Bio import SeqIO
from statistics import median


# help section
if len(sys.argv) == 1:
	sys.argv.append("--help")

if (sys.argv[1] in ["--help", "-h", "-help", "help", "getopt", "usage"]):
	sys.stderr.write("""

Calculate heterozygous and homozygous SNP density from a VCF file and a reference
FASTA genome sequence 

Usage:
jloh density --vcf <VCF> --genome-file <GENOME_FILE> [options]

[default mode]
--vcf               Input VCF file to use for density calculations              [!]
--ref               Reference FASTA genome on which SNPs were called            [!]

[hybrid mode]
--hybrid            Activate hybrid mode                                        [off]
--vcf-A             Input VCF file from parent A                                [!]
--ref-A             Reference FASTA genome from parent A                        [!]
--vcf-B             Input VCF file from parent B                                [!]
--ref-B             Reference FASTA genome from parent B                        [!]

""")
	sys.exit(0)


p = ap.ArgumentParser()
# default options
p.add_argument("--vcf")
p.add_argument("--ref")
# hybrid options
p.add_argument("--hybrid", action="store_true")
p.add_argument("--vcf-A")
p.add_argument("--ref-A")
p.add_argument("--vcf-B")
p.add_argument("--ref-B")

args = p.parse_args()


# functions

def check_conditions(args):

	"""
	Last update: 03/03/2022
	"""

	if args.print_info:
		print(script_info)
		sys.exit(0)

	if ((not args.vcf and not args.ref) and not args.hybrid):
		sys.stderr.write("ERROR: when using the default mode you must provide a VCF and a REF\n")
		sys.stderr.write("See --vcf, --ref options\n")
		sys.exit()

	if (args.hybrid and (not args.vcf_A and not args.vcf_B and not args.ref_A and not args.ref_B)):
		sys.stderr.write("ERROR: when using the --hybrid mode you must provide a VCF and a REF for both A and B subgenomes\n")
		sys.stderr.write("See --vcf-A, --vcf-B, --ref-A, --ref-B options\n")
		sys.exit()

	return True



def hetero_and_homo_snps(vcf):

	"""
	Last update: 03/03/2022
	"""

	# read SNPs
	INPUT = open(vcf, "r")
	Vcf_lines = [ line for line in INPUT if line[0] != "#" ]
	INPUT.close()

	Het_lines, Homo_lines = [],[]

	for line in Vcf_lines:

		# split by field
		lst = line.rstrip("\b\r\n").split("\t")

		# read values
		annotations = lst[8].split(":")
		values = lst[9].split(":")
		dict = { annotations[i]:values[i] for i in range(0, len(annotations)) }

		# if it's a single heterozygous SNP
		if ((len(lst[3]) == len(lst[4]) == 1) and (dict["GT"]=="0/1")):

			# 4. write out lines that have fitting values
			Het_lines.append(line)

		# if homozygous: keep for later assignment to blocks
		elif ((len(lst[3]) == len(lst[4]) == 1) and (dict["GT"]=="0/0") \
		or (len(lst[3]) == len(lst[4]) == 1) and (dict["GT"]=="1/1")):

			Homo_lines.append(line)

		# consider multiallelic sites
		# only if all alleles are SNPs
		# and if all alleles are not stars (spanning deletions)
		elif ((len(lst[3]) == 1) and (len(lst[4].split(",")) > 1)
		and (all([ len(x)==1 for x in lst[4].split(",") ])) \
		and (all([ x!="*" for x in lst[4].split(",") ]))):

			# this means that there are two annotations for AF
			# and that both have to be checked
			# so it is a variation on the previous block
			# which could be rendered into a function
			# assuming that there are > 1 AF annotation
			# splitting the field based on the comma
			# and converting to float the content
			AFs = [ float(x) for x in dict["AF"].split(",") ]

			# all it takes is one of the variants to be heterozygous
			# for the locus to be conserved
			# where het = AF comprised between --min-af and --max-af
			# 4. write out lines that have fitting values
			Het_lines.append(line)

	return Het_lines, Homo_lines


def parse_chromosomes(ref):

	"""
	Last update: 03/03/2022
	"""

	Chrom_lengths = {}
	for record in SeqIO.parse(ref, "fasta"):
		id = record.id
		seq = record.seq
		seqlen = len(seq)
		Chrom_lengths[id] = seqlen

	return Chrom_lengths


def is_a_snp(line):

	"""
	Last update: 03/03/2022
	"""

	lst = line.rstrip("\r\b\n").split("\t")
	ref, alt = lst[3].split(","), lst[4].split(",")
	if (all([len(x)==1 for x in ref]) and all([len(y)==1 for y in alt])) == True:
		return True
	else:
		return False


def calculate_chrom_snp_densities(Variants, ref):

	"""
	Last update: 03/03/2022
	"""

	# extract SNPs and chromosome lengths
	# subdivide SNPs by chromosome
	Snps = [ (line.split("\t")[0], line) for line in Variants if is_a_snp(line) == True ]
	Chrom_lengths = parse_chromosomes(ref)
	Snps_by_chrom = { chrom : [] for chrom in Chrom_lengths.keys() }

	for snp in Snps:
		Snps_by_chrom[snp[0]].append(snp[1])

	# calculate densities by chromosome
	Snp_densities = { chrom : len(Snps_by_chrom[chrom]) / (int(Chrom_lengths[chrom]) / 1000) for chrom in Snps_by_chrom.keys() }

	return Snp_densities



def run_in_default_mode(args):

	"""
	Last update: 03/03/2022
	"""

	# split
	Hetero_lines, Homo_lines = hetero_and_homo_snps(args.vcf)

	# hetero
	Het_snp_densities = calculate_chrom_snp_densities(Hetero_lines, args.ref)
	hetero_div = median([float(i) for i in Het_snp_densities.values()])
	hetero_div = round(hetero_div, 2)

	# homo
	Homo_snp_densities = calculate_chrom_snp_densities(Homo_lines, args.ref)
	homo_div = median([float(i) for i in Homo_snp_densities.values()])
	homo_div = round(homo_div, 2)

	return hetero_div, homo_div


def run_in_hybrid_mode(args):

	"""
	Last update: 04/03/2022
	"""

	# split
	sys.stderr.write(f"[{at()}] Extracting heterozygous and homozygous SNPs...\n")
	Hetero_lines_A, Homo_lines_A = hetero_and_homo_snps(args.vcf_A)
	Hetero_lines_B, Homo_lines_B = hetero_and_homo_snps(args.vcf_B)

	# hetero
	sys.stderr.write(f"[{at()}] Calculating heterozygous and homozygous SNP density in both parental genomes...\n")
	Het_snp_densities_A = calculate_chrom_snp_densities(Hetero_lines_A, args.ref_A)
	Het_snp_densities_B = calculate_chrom_snp_densities(Hetero_lines_B, args.ref_B)
	het_avg_divergence_A = median([float(i) for i in Het_snp_densities_A.values()])
	het_avg_divergence_B = median([float(i) for i in Het_snp_densities_B.values()])

	hetero_div = round((het_avg_divergence_A + het_avg_divergence_B) / 2, 2)

	# homo
	Homo_snp_densities_A = calculate_chrom_snp_densities(Homo_lines_A, args.ref_A)
	Homo_snp_densities_B = calculate_chrom_snp_densities(Homo_lines_B, args.ref_B)
	homo_avg_divergence_A = median([float(i) for i in Homo_snp_densities_A.values()])
	homo_avg_divergence_B = median([float(i) for i in Homo_snp_densities_B.values()])

	homo_div = round((homo_avg_divergence_A + homo_avg_divergence_B) / 2, 2)

	return hetero_div, homo_div


def main(args):

	"""
	Last update: 04/03/2022
	"""

	# check conditions before starting
	tmp = check_conditions(args)

	# run in the selected mode
	if args.hybrid:
		homo_div, hetero_div = run_in_hybrid_mode(args)

	else:
		homo_div, hetero_div = run_in_default_mode(args)

	# write divergence to output
	sys.stdout.write(f"{hetero_div} heterozygous SNPs/kbp\n")
	sys.stdout.write(f"{homo_div} homozygous SNPs/kbp\n")


if __name__ == "__main__":
	main(args)
